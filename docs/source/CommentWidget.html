<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function ($) { if (CKEDITOR &amp;&amp; CKEDITOR.Comments &amp;&amp; !CKEDITOR.CommentWidget) {

<span id='CKEDITOR-CommentWidgetDefinition'>  /**
</span>   * Provides the &quot;comment&quot; widget definition.
   * @param {CKEDITOR.editor} editor
   *   The editor instance.
   * @returns {Object}
   * @static
   * @abstract
   */
  CKEDITOR.CommentWidgetDefinition = function (editor) {
    return {
      defaults: function () {
        var selection = rangy.getSelection(editor.document.$);
        // Attempt to expand word if possible.
        if (selection.isCollapsed) {
          selection.expand(&#39;word&#39;);
          selection.refresh();
        }
        selection.trim();
        return {
          content: selection.toHtml()
        };
      },
      editables: {
        content: {
          selector: &#39;.comment-content&#39;
        }
      },
      parts: {
        content: &#39;.comment-content&#39;
      },
      requiredContent: &#39;comment&#39;,
      template: &#39;&lt;comment&gt;&lt;span class=&quot;comment-content&quot;&gt;{content}&lt;/span&gt;&lt;/comment&gt;&#39;,
      init: function () {
        if (!editor.Comments._initialized) {
          editor.widgets.destroy(this);
          return;
        }
        // Element already exists in DOM or new widget has data content.
        if (this.element.getDocument().equals(editor.document) || this.data.content.length) {
          // If element exists in DOM, but has no data content, set it.
          if (!this.data.content.length) {
            this.setData(&#39;content&#39;, this.element.getHtml());
          }
          // Instantiate a new CommentWidget class to manage this widget.
          editor.Comments.subclass(CKEDITOR.CommentWidget, this);
        }
        // Not a valid widget, destroy it.
        else {
          editor.widgets.del(this);
        }
      },
      upcast: function(element) {
        return element.name === &#39;comment&#39;;
      }
    };
  };

<span id='CKEDITOR-CommentWidget-method-constructor'><span id='CKEDITOR-CommentWidget'>  /**
</span></span>   * This class manages the comment widget for CKEditor. This class should
   * not be used directly. It is automatically instantiated when a
   * CKEDITOR.Comments instance is created.
   *
   * @constructor
   *   Initializes an instance of this class.
   *
   * @param {CKEDITOR.plugins.widget} widget
   * @returns {CKEDITOR.CommentWidget}
   */
  CKEDITOR.CommentWidget = function(widget) {
    var self = this;
    self.comment = {};
    if (!widget) {
      return self;
    }
    widget.on(&#39;blur&#39;,     self.blur);
    widget.on(&#39;data&#39;,     self.data);
    widget.on(&#39;destroy&#39;,  self.destroy);
    widget.on(&#39;focus&#39;,    self.focus);
    widget.on(&#39;ready&#39;,    self.ready);
    self.widget = widget;
    return self;
  };

  CKEDITOR.CommentWidget.prototype = {

<span id='CKEDITOR-CommentWidget-method-blur'>    /**
</span>     * Fired when comment widget has been blurred.
     * @param {CKEDITOR.eventInfo} evt
     */
    blur: function (evt) {
      var widget = evt.sender;
      if (widget.comment._editing) {
        evt.stop();
        return;
      }
      if (!widget.comment._destroying) {
        widget.comment.inlineElement.removeClass(&#39;active&#39;);
        widget.comment.sidebarElement.removeClass(&#39;active&#39;);
        if (widget.comment.cid === 0 &amp;&amp; !widget.comment._saving) {
          widget.comment.destroy();
        }
      }
    },

<span id='CKEDITOR-CommentWidget-method-data'>    /**
</span>     * Fired when the comment widget data has been changed.
     * @param {CKEDITOR.eventInfo} evt
     */
    data: function (evt) {
      var widget = evt.sender;
      widget.element.setHtml(widget.data.content);
    },

<span id='CKEDITOR-CommentWidget-method-destroy'>    /**
</span>     * Fired when comment widget is destroyed.
     * @param {CKEDITOR.eventInfo} evt
     */
    destroy: function (evt) {
      var widget = evt.sender;
      widget.editor.undoManager.lock(true);
      widget.comment.sidebarElement.remove();
      widget.editor.insertHtml(widget.data.content);
      widget.editor.undoManager.unlock();
    },

<span id='CKEDITOR-CommentWidget-method-focus'>    /**
</span>     * Fired when comment widget has been focused.
     * @param {CKEDITOR.eventInfo} evt
     */
    focus: function (evt) {
      var widget = evt.sender;
      if (!widget.comment._destroying) {
        // Focus this comment.
        widget.comment.inlineElement.addClass(&#39;active&#39;);
        widget.comment.sidebarElement.addClass(&#39;active&#39;);

        // Re-arrange touching comments.
        widget.comment.arrangeComments();
      }
    },

<span id='CKEDITOR-CommentWidget-method-ready'>    /**
</span>     * Fired when comment widget was successfully created and is ready.
     * @param {CKEDITOR.eventInfo} evt
     */
    ready: function (evt) {
      var widget = evt.sender;
      widget.dialog = &#39;comment&#39;;
      if (!widget.comment) {
        var comment = widget.editor.Comments.subclass(CKEDITOR.Comment, { inlineElement: $(widget.element.$)});
        comment.widget = widget;
        widget.comment = comment;
      }
    }

  };

}})(jQuery);
</pre>
</body>
</html>
