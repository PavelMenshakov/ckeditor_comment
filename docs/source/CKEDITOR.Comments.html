<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='CKEDITOR-Comments-method-constructor'><span id='CKEDITOR-Comments'>/**
</span></span> * Class that handles instances of CKEDITOR.Comments.
 *
 * @constructor
 *   Creates a new CKEDITOR.Comments() instance for editor.
 *
 * @param {CKEDITOR.editor} editor
 *   A CKEDITOR.editor instance.
 *
 *     var instance = new CKEDITOR.Comments(editor);
 *
 * @returns {CKEDITOR.Comments}
 */
CKEDITOR.Comments = function(editor) {
  var self = this;

<span id='CKEDITOR-Comments-property-_initialized'>  /**
</span>   * State determining whether this Comments instance is initialized.
   *
   * @property {boolean} _initialized
   * @private
   */
  self._initialized = false;

<span id='CKEDITOR-Comments-property-comments'>  /**
</span>   * Contains the comment IDs (cids) of initialized comments.
   *
   * @property {object} comments
   */
  self.comments = {};

<span id='CKEDITOR-Comments-property-tempCid'>  /**
</span>   * A temporary CID value used to unsaved comments (should always be &lt;= 0).
   *
   * @property {object} tempCid
   */
  self.tempCid = 0;

<span id='CKEDITOR-Comments-property-editor'>  /**
</span>   * The CKEDITOR.editor instance used in construction.
   *
   * @property {CKEDITOR.editor} [editor=]
   */
  self.editor = editor;

<span id='CKEDITOR-Comments-property-data'>  /**
</span>   * Data set properties of the editor&#39;s textarea element.
   * 
   * @property {object} [data={}]
   */
  self.data = $.extend(true, {
    commentsEnabled: false
  }, $(&#39;#&#39; + editor.name).data());

<span id='CKEDITOR-Comments-property-enabled'>  /**
</span>   * Status on whether commenting is enabled.
   * 
   * @property {boolean} [enabled=false]
   */
  self.enabled = self.data.commentsEnabled || false;

<span id='CKEDITOR-Comments-property-activeComment'>  /**
</span>   * The current comment activated (focused).
   * 
   * @property {(boolean|CKEDITOR.Comment)} activeComment
   */
  self.activeComment = false;

<span id='CKEDITOR-Comments-property-loaded'>  /**
</span>   * Property determining whether instance has loaded.
   * 
   * @property {boolean} loaded
   */
  self.loaded = false;

<span id='CKEDITOR-Comments-property-removeQueue'>  /**
</span>   * Queue containing the comment IDs (cids) of comments needed to be removed.
   *
   * @property {array} removeQueue
   */
  self.removeQueue = [];

<span id='CKEDITOR-Comments-property-saveQueue'>  /**
</span>   * Queue containing the comment IDs (cids) of comments needed to be saved.
   *
   * @property {array} saveQueue
   */
  self.saveQueue = [];

<span id='CKEDITOR-Comments-property-sidebar'>  /**
</span>   * The sidebar DOM jQuery Object used to contain comments.
   *
   * @property {jQuery} [sidebar=$()]
   */
  self.sidebar = $();

<span id='CKEDITOR-Comments-property-users'>  /**
</span>   * An object used to cache the users of comments. 
   * 
   * @property {Object} users
   */
  self.users = {};

  return self;
};

CKEDITOR.Comments.prototype = {

<span id='CKEDITOR-Comments-method-init'>  /**
</span>   * Initializes a CKEDITOR.Comments instance.
   */
  init: function() {
    var self = this;
    if (self._initialized) {
      return;
    }
    self.createSidebar();
    self.loadComments();
    // Detect comments on selectionChange.
    self.editor.on(&#39;selectionChange&#39;, self.selectionChange);
    self._initialized = true;
  },

<span id='CKEDITOR-Comments-method-selectionChange'>  /**
</span>   * Event handler for CKEDITOR selectionChange event.
   * @param {CKEDITOR.eventInfo} e
   */
  selectionChange: function (e) {
    var self = e.editor.comments;
    // Remove this listener from the editor so we can make changes without this
    // event again.
    e.removeListener();
    self.sort();
    // Add listener back onto editor now that we&#39;re done.
    e.editor.on(&#39;selectionChange&#39;, self.selectionChange);
    var range = e.data.selection.getRanges()[0];
    window.console.log(range);
    window.console.log(range.startContainer.getParent().$);
    if (range.collapsed) {
      var parent = range.startContainer.getParent().$;
      if (parent.nodeName === &quot;COMMENT&quot;) {
        parent._.activate();
      }
      else if (self.activeComment) {
        self.activeComment.deactive();
      }
    }
    else if (self.activeComment) {
      self.activeComment.deactive();
    }
  }
};

<span id='CKEDITOR-Comments-method-ajax'>/**
</span> * AJAX callback for retrieving data using default parameters.
 *
 * @param {string} action
 * @param {Object} options
 */
CKEDITOR.Comments.prototype.ajax = function (action, options) {
  options = options || {};
  var defaults = {
    url: Drupal.settings.basePath + &#39;ajax/ckeditor/comment&#39;,
    type: &#39;POST&#39;,
    dataType: &#39;json&#39;,
    data: this.data
  };
  options = $.extend(true, defaults, options);
  options.data.action = action;
  $.ajax(options);
};

<span id='CKEDITOR-Comments-method-loadComments'>/**
</span> * Load existing comments for this instance.
 */
CKEDITOR.Comments.prototype.loadComments = function() {
  var self = this;

  // Only load comments once per instance.
  if (self.loaded) {
    return;
  }

  // Lock editor while loading comments.
  self.editor.setReadOnly(true);

  var $loading = $(&#39;&lt;div class=&quot;loading&quot;&gt;Please wait...&lt;/div&gt;&#39;);
  self.sidebar.append($loading);

  // Instantiate existing comments.
  $(this.editor.document.$).find(&#39;body comment&#39;).each(function () {
    var $inlineElement = $(this);
    var options = $.extend(true, { inlineElement: $inlineElement }, $inlineElement.data());
    var comment = new CKEDITOR.Comment(self, options);
    if (!comment.cid) {
      comment.remove();
    }
  });

  // Load comments from database.
  self.ajax(&#39;comment_load&#39;, {
    data: {
      comments: self.data.cids
    },
    success: function (json) {
      self.template = json.template;
      for (var i = 0; i &lt; json.comments.length; i++) {
        var comment = new CKEDITOR.Comment(self, json.comments[i]);
        if (comment.cid &amp;&amp; !self.comments[comment.cid]) {
          self.createComment(comment);
        }
      }
    },
    complete: function () {
      $loading.remove();
      self.editor.setReadOnly(false);
    }
  });
  self.loaded = true;
};

<span id='CKEDITOR-Comments-method-createSidebar'>/**
</span> * Create the sidebar for containing the actual comments in the editor.
 */
CKEDITOR.Comments.prototype.createSidebar = function () {
  var self = this;
  if (self.sidebar.length) {
    return;
  }
  self.sidebar = $(&#39;&lt;comments/&gt;&#39;).addClass(&#39;cke-comments-sidebar&#39;).attr(&#39;data-widget-wrapper&#39;, &#39;true&#39;).appendTo($(self.editor.document.$).find(&#39;html&#39;));
  $(window).on(&#39;resize.cke-comments-sidebar&#39;, function () {
    self.sidebarResize();
  });
  this.editor.on(&#39;afterCommandExec&#39;, function (e) {
    if (e.data.name === &#39;maximize&#39;) {
      self.sidebarResize();
    }
  });
};

CKEDITOR.Comments.prototype.sidebarResize = function () {
  var self = this;
  var $document = $(self.editor.document.$);
  var $body = $document.find(&#39;body&#39;);
  self.sidebar.css(&#39;left&#39;, (($document.find(&#39;html&#39;).width() - $body.outerWidth(false)) / 2) + $body.outerWidth(false) + 20) ;
};

<span id='CKEDITOR-Comments-method-sort'>/**
</span> * Sort comments in sidebar.
 */
CKEDITOR.Comments.prototype.sort = function () {
  var i, $inlineComments = $(this.editor.document.$).find(&#39;body comment&#39;);
  for (i = 0; i &lt; $inlineComments.length; i++) {
    if ($inlineComments[i]._ &amp;&amp; $inlineComments[i]._.sidebarElement.get(0)) {
      $inlineComments[i]._.sidebarElement.get(0).commentIndex = i;
      this.updateCharacterRange($inlineComments[i]);
    }
  }
  var $sidebarComments = this.sidebar.find(&#39;comment&#39;);
  if ($sidebarComments.length) {
    // Sort based on inline comment positions in editor.
    $sidebarComments.sort(function(a, b) {
      if (a.commentIndex &gt; b.commentIndex) {
        return 1;
      }
      else if (a.commentIndex &lt; b.commentIndex) {
        return -1;
      }
      else {
        return 0;
      }
    });
    this.sidebar.append($sidebarComments);
  }
};

<span id='CKEDITOR-Comments-method-updateCharacterRange'>/**
</span> * Update an element&#39;s character range, saving if necessary.
 */
CKEDITOR.Comments.prototype.updateCharacterRange = function (element) {
  var selection = rangy.getSelection(this.editor.document.$);
  var _cke_ranges = this.editor.getSelection().getRanges();
  this.editor.getSelection().lock();
  selection.selectAllChildren(element);
  var newCharacterRange = selection.saveCharacterRanges();
  if (JSON.stringify(newCharacterRange) !== JSON.stringify(element._.character_range)) {
    window.console.log(&#39;&quot;&#39; + selection.toString() + &#39;&quot;: new character range&#39;);
    element._.character_range = newCharacterRange;
  }
  else {
    window.console.log(&#39;&quot;&#39; + selection.toString() + &#39;&quot;: same character range&#39;);
  }
  this.editor.getSelection().selectRanges(_cke_ranges);
  this.editor.getSelection().unlock();
};

<span id='CKEDITOR-Comments-method-closestComment'>/**
</span> * Find closest comments based on editor cursor position.
 */
CKEDITOR.Comments.prototype.closestComment = function() {
  var self = this,
      selection = self.editor.getSelection(),
      startElement = selection.getStartElement(),
      comment = $();
  if (startElement) {
    comment = $(startElement.$).closest(&#39;comment&#39;);
    // Try finding first child comment.
    if (!comment.length) {
      comment = $(startElement.$).find(&#39;comment:first&#39;);
    }
    // Try finding first parent child comment.
    if (!comment.length) {
      comment = $(startElement.$).parent().find(&#39;comment:first&#39;);
    }
  }
  // Try finding first comment in entire editor.
  if (!startElement || !comment.length) {
    comment = $(self.editor.document.$).find(&#39;comment:first&#39;);
  }
  if (comment.length &amp;&amp; comment.get(0)._ &amp;&amp; comment.get(0)._ instanceof CKEDITOR.Comment) {
    return comment.get(0)._;
  }
  return false;
};

<span id='CKEDITOR-Comments-method-arrangeComments'>/**
</span> * Arrange comments around the comment this was called on.
 * @param {CKEDITOR.Comment} [comment]
 */
CKEDITOR.Comments.prototype.arrangeComments = function(comment) {
  var self = this;
  comment = comment || self.activeComment || self.closestComment();
  if (comment &amp;&amp; comment.sidebarElement.length) {
    var beforeTop, beforeComment, commentsBefore = comment.sidebarElement.prevAll(&#39;comment&#39;).toArray();
    var afterTop, afterComment, commentsAfter = comment.sidebarElement.nextAll(&#39;comment&#39;).toArray();
    beforeTop = afterTop = comment.sidebarElement.get(0).newTop = comment.findTop();

    self.sidebar.find(&#39;comment&#39;).stop(true);

    var animateSidebarComment = function() {
      this._.sidebarElement.animate({top: this.newTop + &#39;px&#39;});
      delete this.newTop;
    };

    comment.sidebarElement.queue(&#39;arrangeComments&#39;, animateSidebarComment);
    while (commentsBefore.length || commentsAfter.length) {
      if (commentsBefore.length) {
        beforeComment = commentsBefore.splice(0,1)[0];
        beforeTop -= $(beforeComment).outerHeight(false) + 10;
        beforeComment.newTop = beforeTop;
        $(beforeComment).queue(&#39;arrangeComments&#39;, animateSidebarComment);
      }
      if (commentsAfter.length) {
        afterComment = commentsAfter.splice(0,1)[0];
        afterTop += $(afterComment).outerHeight(false) + 10;
        afterComment.newTop = afterTop;
        $(afterComment).queue(&#39;arrangeComments&#39;, animateSidebarComment);
      }
    }
    self.sidebar.find(&#39;comment&#39;).dequeue(&#39;arrangeComments&#39;);
  }
};

<span id='CKEDITOR-Comments-method-createComment'>/**
</span> * Creates a CKEDITOR.Comment for this instance.
 *
 * @param {CKEDITOR.Comment} [comment={}]
 * @param {boolean} [activate=true]
 */
CKEDITOR.Comments.prototype.createComment = function(comment, activate) {
  var self = this;

  comment = comment || {};
  activate = activate || true;

  var readOnly = self.editor.readOnly;
  if (readOnly) {
    self.editor.setReadOnly(false);
  }
  var selection = rangy.getSelection(self.editor.document.$);
  if (comment.character_range) {
    selection.restoreCharacterRanges(self.editor.document.getBody().$, comment.character_range);
  }
  else {
    selection.expand(&#39;word&#39;);
    selection.refresh();
    comment.character_range = selection.saveCharacterRanges();
  }
  var $element = $(&#39;&lt;comment/&gt;&#39;)
    .html(selection.toHtml())
    .attr(&#39;data-cid&#39;, comment.cid);
  self.editor.insertElement(new CKEDITOR.dom.element($element.get(0)));
  comment.inlineElement = $element;
  if (!(comment instanceof CKEDITOR.Comment)) {
    comment = new CKEDITOR.Comment(self, comment);
    comment.edit();
  }
  if (activate) {
    comment.activate();
  }
  if (readOnly) {
    self.editor.setReadOnly(true);
  }
};
</pre>
</body>
</html>
